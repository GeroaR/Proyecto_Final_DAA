#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
//#include <windows.h>
#define NUM_MAX_PEDIDOS CHAR_M
#define CHAR_S 30
#define CHAR_M 60
#define CHAR_G 120

#define NUM_MAX_DEMANDAS 100

//esta puede variar de acuerdo al maximo o minimo de un camion
int NUM_MAX_CARGA_PESO_KG = 500; 
int NUM_MAX_CARGA_VOL_M3 = 500;

// --------------------------------------------------------------

struct Localidad;
struct  PedidosxDireccion;

struct Nodo;
struct Cola;

struct Cola colaLoc;

//prioridad por numero de demanda

//listas de tipo ENUM
typedef enum {
    KG, G, M3, CM3, KM, H, MIN
} Unidad;

typedef enum { 
    DISPONIBLE,EN_RUTA,MANTENIMIENTO
} EstadoCamion;

typedef enum { 
    EN_ESPERA ,EN_CAMINO,COMPLETADO
} EstadoPedidos;

// -------------------------------

//structs para m√°s clarida de inserci√≥n
typedef struct {
    int contador_ids;
    int tam;
} ColaHeader;

typedef struct {
    float valor;
    Unidad unidad;
} Medida;

typedef struct {
    float lat;
    float lon;
} Coordenadas;

typedef struct {
    int id;
    struct Localidad *R_localidad; //*R_Localidad
    int id_localidad; //*R_Localidad
    int id_cliente;
    int activo; // 1: Activo, 0: Eliminado
    char calle[CHAR_M]; //Calle del cliente
    char numero[CHAR_S]; //N√∫mero exterior/interior (I:1340|E:B-20|)
    char colonia[CHAR_M]; //Colonia o barrio
    char referencias[CHAR_G]; //Descripci√≥n adicional (opcional)
    struct Cola *historial_pedidos;
} Direccion; //ordenarlo POR LOCALIDAD

// -------------------------------

//structs CATEGORIA, PRODUCTO, DEMANDA Y PEDIDO
typedef struct {
    int id;
    char nombre[CHAR_M];
    int numxcategoria; //cantidad de productos por categoria
    int estado; // 0: Inactivo, 1: Activo
} Categoria;

typedef struct {
    int id;
    Categoria *R_categoria; //si se elimina una categoria, pasa a ser: SIN CATEGORIA
    int id_categoria;
    char nombre[CHAR_S];
    float valor; //Valor econ√≥mico
    Medida peso; //En kg o g
    Medida volumen; //En m^3 o cm^3
    int stock; //cantidad de producto en almacenamiento
    int estado; // 0: Inactivo, 1: Activo
} Producto; 
/*
Para buscar productos de acuerdo a categor√≠as: 
    -Usar CountingSort
*/

typedef struct {
    Producto *id_producto; //*R_Producto
    int cantidad; //cuantas unidades
} Pedido;

typedef struct {
    int id;
    Direccion *id_direccion; //R_Direccion -> *R_Localidad (a cu√°l direcci√≥n del cliente)

    Pedido pedidos[NUM_MAX_PEDIDOS]; //ARRAY de pedidos
    int num_pedidos;
    float total_valor; //total a pagar
    Medida total_peso; //total de KG/G
    Medida total_volumen; //total de M3/CM3
    EstadoPedidos estado;
} PedidosxDireccion;
/*
Historial de Pedidos del Cliente
    -Que muestre los productos qu√© m√°s ha pedido el cliente
    -√öltimpos pedidos realizados
    -Se podr√≠a usar CountingSort
*/

// -------------------------------

typedef struct {
    int id;
    PedidosxDireccion *pedidos_clientes; //*R_Pedidos_Clientes x Localidad
    int num_pedidosxdireccion;
    int total_productos;
    float total_valor; //total a ganar
    Medida total_peso; //total de KG/G
    Medida total_volumen; //total de M3/CM3
} DemandasxLocalidad;

//structs LOCALIDAD, CARRETERA y RUTA
typedef struct Localidad{
    int id;
    char nombre[CHAR_M];
    Coordenadas coor;
    int estado;
} Localidad;

typedef struct {
    int *id_origen; //*R_Localidad
    int *id_destino; //*R_Localidad
    Medida distancia; //km
    float tiempo; //horas
    float penalizacion; //factor de tr√°fico
} Carretera;

typedef struct {
    int id;
    int id_camion;
    int *demandasxlocalidad; //en el arreglo debe coincidir la localidad con la demanda
    int *carreteras;
    int total_paradas;
    int total_tiempo;
    int total_distancia;
} Ruta; //el cami√≥n va recorriendo las carreteras en cierto tiempo, llega, pasa cierto tiempo y se marca completado en los pedidos.

// -------------------------------

//structs CAMION y CLIENTE
typedef struct {
    int id;
    Medida capacidad_peso;
    Medida capacidad_volumen;
    Ruta *historial_rutas;
    EstadoCamion estado;
} Camion; //COLA


// COLAS (B√°sicos)
typedef struct Nodo{
    void *dato;
    struct Nodo *siguiente;
} Nodo;

typedef struct Cola{
    Nodo *frente;
    Nodo *final;
    int tam;
    int contador_ids;  // opcional si tus entidades tienen id
}Cola;

typedef struct {
    int id;
    int id_cliente;
    Direccion *direccion;
} Cliente_Direccion; //COLA

typedef struct {
    int id;
    char nombre[CHAR_S];
    Cola direcciones;
    int num_pedidos; //cantidad de pedidos realizados
} Cliente; //COLA

void limpiar_buffer();
int leer_float_seguro(float *numero);
int leer_int_seguro(int *numero);


int validar_medida(Medida m, const char* campo);
int es_texto_valido(char texto[],const char* campo);
int esta_en_rango(float valor, float min, float max, const char* campo);
void mostrar_unidades_posibles(Unidad opciones[], int num_opciones);
Medida pedir_medida(Unidad opciones[], int num_opciones, const char* campo);
Coordenadas pedir_coordenadas();

Categoria* crearCategoria(Cola *cola, char nombre[]);
int criterioCategoriaPorID(void *dato);
void mostrarCategoria(void *dato);
Categoria *buscarCategoria(Cola *colaCat, int idCat);
void editarCategoriaNombre(void *dato);

Localidad* crearLocalidad(Cola *cola, char nombre[], Coordenadas coor);
int criterioLocalidadPorID(void *dato);
void mostrarLocalidad(void *dato);
Localidad *buscarLocalidad(Cola *colaLoc, int idLoc);
void editarLocalidad(void *dato);

Producto* crearProducto(Cola *cola, char nombre[], Categoria *R_categoria, float valor, Medida peso, Medida volumen, int stock);
int criterioProductoPorID(void *dato);
void mostrarProducto(void *dato);
void editarProducto(void *dato);
void eliminarProducto(void *dato);
void reconstruirReferenciasProducto(Cola *productos, Cola *categorias);
void limpiarReferenciasProducto(Cola *productos);

Direccion *crearDireccion(Cola *cola, Localidad *localidad, int id_cliente, char calle[], char numero[], char colonia[], char referencias[]);
Cliente_Direccion* crearCliente_Direccion(Cola *cola, Direccion *direccion, int id_cliente);
int criterioDireccionPorID(void *dato);
int criterioClienteDireccionPorID(void *dato);
void mostrarDireccion(void *dato);
void mostrarClienteDireccion(void *dato);
void editarClienteDireccion(void *dato);
Cliente_Direccion *buscarClienteDireccion(Cola *colaClienteDir, int idDirecc);
void eliminarDireccion(void *dato);
void limpiarReferenciasDireccion(Cola *colaDirecc);
void asociarLocalidadesADirecciones(Cola *colaDirecc, Cola *colaLoc);


Cliente* crearCliente(Cola *cola, char nombre[]);
int criterioClientePorID(void *dato);
void mostrarCliente(void *dato);
void editarCliente(void *dato);
Cliente *buscarCliente(Cola *cola, int id_buscar);
void agregarDireccionesACliente(Cliente *cliente, Cola *colaLoc, Cola *colaDirecc);
void limpiarReferenciasClienteDireccion(Cola *colaCliente, Cola *colaDirecc);


void inicializarCola(Cola *cola);
Nodo *encolar(Cola *cola, void *dato, size_t tam_dato);
void *desencolar(Cola *cola);
void listarCola(Cola *cola, void (*mostrar)(void *));
void editarCola(Cola *cola, int (*criterio)(void *), void (*editar)(void *));
void cargarCola(Cola *cola, const char *nombre_archivo, size_t tam_dato);
void guardarCola(Cola *cola, const char *nombre_archivo, size_t tam_dato);
void liberarCola(Cola *cola);
Nodo *extraerNodoPorCriterio(Cola *cola, int (*criterio)(void *));

int menu_edicion(const char *titulo, const char *campos[], int num_campos);
const char* obtener_nombre_unidad(Unidad u);

void submenu_categoria(Cola *colaCat);
void submenu_localidad(Cola*colaLoc);
void submenu_cliente(Cola *colaCliente, Cola *colaLoc, Cola *colaDirecc);
void menu_admin(Cola *colaCat, Cola *colaLoc, Cola *colaProd, Cola *colaCliente, Cola *colaDirecc);

// --------------------------- FUNCIONES PARA EVITAR ERROR DE INSERCION ---------------------------

// Limpia el buffer en caso de entrada incorrecta
void limpiar_buffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}

// Leer float validado
int leer_float_seguro(float *numero) {
    char buffer[100];
    char *endptr;

    if (fgets(buffer, sizeof(buffer), stdin) == NULL) return 0;
    *numero = strtof(buffer, &endptr);

    if (endptr == buffer || *endptr != '\n') {
        return 0; // error de conversi√≥n
    }
    return 1;
}

// Leer int validado
int leer_int_seguro(int *numero) {
    char buffer[100];
    char *endptr;

    if (fgets(buffer, sizeof(buffer), stdin) == NULL) return 0;
    *numero = strtol(buffer, &endptr, 10);

    if (endptr == buffer || *endptr != '\n') {
        return 0; // error de conversi√≥n
    }
    return 1;
}

// --------------------------- VALIDACION INFORMACION ---------------------------
int validar_medida(Medida m, const char* campo) {
    if (m.valor < 0) {
        printf("‚ùå Error en %s: valor negativo.\n", campo);
        return 0;
    }
    return 1;
}

int es_texto_valido(char texto[],const char* campo) {
    if (!strlen(texto)) {
        printf("‚ùå Error en %s: campo vacio.\n", campo);
        return 0;
    }
    return 1;
}

int esta_en_rango(float valor, float min, float max, const char* campo) {
    if (valor < min || valor > max) {
        printf("‚ùå Error: %s fuera de rango (%.2f - %.2f). Valor recibido: %.2f\n", campo, min, max, valor);
        return 0;
    }
    return 1;
}

void mostrar_unidades_posibles(Unidad opciones[], int num_opciones) {
    printf("Unidades disponibles:\n");
    for (int i = 0; i < num_opciones; i++) {
        printf(" %d. ", opciones[i]);
        switch(opciones[i]) {
            case KG: printf("KG\n"); break;
            case G: printf("G\n"); break;
            case M3: printf("M3\n"); break;
            case CM3: printf("CM3\n"); break;
            case KM: printf("KM\n"); break;
            case H: printf("Horas\n"); break;
            case MIN: printf("Minutos\n"); break;
        }
    }
}

Medida pedir_medida(Unidad opciones[], int num_opciones, const char* campo) {
    Medida m;
    int unidad_valida = 0;
    int opcion_seleccionada = 0;

    do {
        printf("Ingrese el valor de %s: ", campo);
        if (!leer_float_seguro(&m.valor)) {
            printf("‚ùå Entrada invalida. Ingrese un numero valido.\n");
            continue;
        }

        if (!validar_medida(m, campo)) {
            continue;
        }

        mostrar_unidades_posibles(opciones, num_opciones);
        printf("Seleccione la unidad (por numero): ");
        if (!leer_int_seguro(&opcion_seleccionada)) {
            printf("‚ùå Entrada invalida. Vuelva a INGRESAR TODO.\n");
            continue;
        }

        for (int i = 0; i < num_opciones; i++) {
            if (opciones[i] == opcion_seleccionada) {
                m.unidad = opciones[i];
                unidad_valida = 1;
                break;
            }
        }

        if (!unidad_valida) {
            printf("‚ùå Unidad invalida. Intente de nuevo.\n");
        }

    } while (!unidad_valida);

    return m;
}

Coordenadas pedir_coordenadas() {
    Coordenadas c;
    printf("Ingrese la latitud (-90 a 90): ");
    if (!leer_float_seguro(&c.lat)) {
        printf("‚ùå Entrada invalida. Estableciendo latitud a 0.\n");
        c.lat = 0;
    }

    printf("Ingrese la longitud (-180 a 180): ");
    if (!leer_float_seguro(&c.lon)) {
        printf("‚ùå Entrada invalida. Estableciendo longitud a 0.\n");
        c.lon = 0;
    }

    if (c.lat < -90 || c.lat > 90) {
        printf("‚ùå Latitud fuera de rango. Estableciendo a 0.\n");
        c.lat = 0;
    }
    if (c.lon < -180 || c.lon > 180) {
        printf("‚ùå Longitud fuera de rango. Estableciendo a 0.\n");
        c.lon = 0;
    }

    return c;
}

// --------------------------- FUNCIONES CATEGORIA ---------------------------
Categoria* crearCategoria(Cola *cola, char nombre[]) {
    Categoria *nuevo = (Categoria *)malloc(sizeof(Categoria));
    if (!nuevo)
        return NULL;
    cola->contador_ids++;
    nuevo->id = cola->contador_ids;
    strcpy(nuevo->nombre, nombre);
    nuevo->estado = 1;
    nuevo->numxcategoria = 0;
    return nuevo;
}

int criterioCategoriaPorID(void *dato) {
    Categoria *c = (Categoria *)dato;
    int id;
    printf("Ingrese el ID de la categor√≠a a editar: ");
    if (!leer_int_seguro(&id)) {
        printf("‚ùå Entrada inv√°lida.\n");
        return 0;
    }
    return c->id == id;
}

void mostrarCategoria(void *dato) {
    Categoria *c = (Categoria *)dato;
    if (c->estado == 1)
        printf("ID: %d | Nombre: %s\n", c->id, c->nombre);
}

Categoria *buscarCategoria(Cola *colaCat, int idCat){
    Nodo *temp = colaCat->frente;
    while (temp != NULL) {
        Categoria *c = (Categoria *)temp->dato;
        if (c->id == idCat) 
            return c;
        temp = temp->siguiente;
    }
    return NULL;
}

void editarCategoriaNombre(void *dato) {
    Categoria *c = (Categoria *)dato;
    printf("Nuevo nombre de la categor√≠a: ");
    fgets(c->nombre, sizeof(c->nombre), stdin);
    c->nombre[strcspn(c->nombre, "\n")] = 0;
    printf("‚úÖ Nombre actualizado a: %s\n", c->nombre);
}

// --------------------------- FUNCIONES LOCALIDAD ---------------------------
Localidad* crearLocalidad(Cola *cola, char nombre[], Coordenadas coor) {
    Localidad *nuevo = (Localidad *)malloc(sizeof(Localidad));
    if (!nuevo)
        return NULL;
    cola->contador_ids++;
    nuevo->id = cola->contador_ids;
    strcpy(nuevo->nombre, nombre);
    nuevo->coor = coor;
    nuevo->estado = 1;
    return nuevo;
}

int criterioLocalidadPorID(void *dato) {
    Localidad *c = (Localidad *)dato;
    int id;
    printf("Ingrese el ID de la localidad a editar: ");
    if (!leer_int_seguro(&id)) {
        printf("‚ùå Entrada inv√°lida.\n");
        return 0;
    }
    return c->id == id;
}

void mostrarLocalidad(void *dato) {
    Localidad *l = (Localidad *)dato;
    if (l->estado == 1)
        printf("ID: %d | Nombre: %s | Lat: %.2f | Lon: %.2f\n", l->id, l->nombre, l->coor.lat, l->coor.lon);

}

Localidad *buscarLocalidad(Cola *colaLoc, int idLoc) {
    Nodo *tempL = colaLoc->frente;
    while (tempL != NULL) {
        Localidad *l = (Localidad *)tempL->dato;
        if (l->id == idLoc) {
            return l;
        }
        tempL = tempL->siguiente;
    }
    return NULL;
}

void editarLocalidad(void *dato) {
    Localidad *l = (Localidad *)dato;
    int opcion;
    const char *campos[] = {"nombre", "coordenadas"};
    do {
        opcion = menu_edicion(l->nombre,campos,2);
        if (opcion == -1) continue;

        switch (opcion) {
            case 1:
                printf("Nuevo nombre: ");
                fgets(l->nombre, sizeof(l->nombre), stdin);
                l->nombre[strcspn(l->nombre, "\n")] = 0;
                printf("‚úÖ Nombre actualizado.\n");
                break;
            case 2:
                printf("Ingrese nuevas coordenadas:\n");
                l->coor = pedir_coordenadas();
                printf("‚úÖ Coordenadas actualizadas.\n");
                break;
            case 0:
                printf("‚Ü© Volviendo al men√∫ anterior.\n");
                break;
            default:
                printf("‚ùå Opci√≥n inv√°lida.\n");
        }
    } while (opcion != 0);

    return;
}

// --------------------------- FUNCIONES PRODUCTO ---------------------------
Producto* crearProducto(Cola *cola, char nombre[], Categoria *R_categoria, float valor, Medida peso, Medida volumen, int stock) {
    Producto *nuevo = (Producto *)malloc(sizeof(Producto));
    if (!nuevo)
        return NULL;
    cola->contador_ids++;
    nuevo->id = cola->contador_ids;
    strcpy(nuevo->nombre, nombre);
    nuevo->R_categoria = R_categoria;
    nuevo->id_categoria = R_categoria->id;
    nuevo->valor = valor;
    nuevo->peso = peso;
    nuevo->volumen = volumen;
    nuevo->stock = stock;
    nuevo->estado = 1;
    return nuevo;
}

int criterioProductoPorID(void *dato) {
    Producto *p = (Producto *)dato;
    int id;
    printf("Ingrese el ID del producto: ");
    if (!leer_int_seguro(&id)) {
        printf("‚ùå Entrada inv√°lida.\n");
        return 0;
    }
    return p->id == id;
}

void mostrarProducto(void *dato) {
    Producto *p = (Producto *)dato;
    if (p->estado == 1)
        printf("ID: %d | Nombre: %s | Valor: %.2f | Peso: %.2f %s | Volumen: %.2f %s | Stock: %d | Categor√≠a: %s\n",
               p->id, p->nombre, p->valor,
               p->peso.valor, obtener_nombre_unidad(p->peso.unidad),
               p->volumen.valor, obtener_nombre_unidad(p->volumen.unidad),
               p->stock, p->R_categoria->nombre);
}

// Funci√≥n para editar producto con submen√∫ de campos
void editarProducto(void *dato) {
    Producto *p = (Producto *)dato;
    int opcion = 0;
    const char *campos[] = {"nombre", "valor", "peso", "volumen", "stock"};
    do {
        opcion = menu_edicion(p->nombre, campos, 5);
        if (opcion == -1) continue;

        switch (opcion) {
            case 1:
                printf("Nuevo nombre: ");
                fgets(p->nombre, sizeof(p->nombre), stdin);
                p->nombre[strcspn(p->nombre, "\n")] = 0;
                printf("‚úÖ Nombre actualizado.\n");
                break;
            case 2:
                printf("Nuevo valor econ√≥mico: ");
                if (leer_float_seguro(&p->valor)) {
                    printf("‚úÖ Valor actualizado.\n");
                } else printf("‚ùå Entrada inv√°lida.\n");
                break;
            case 3:
                printf("Ingrese nuevo peso:\n");
                p->peso = pedir_medida((Unidad[]){KG, G}, 2, "Peso");
                break;
            case 4:
                printf("Ingrese nuevo volumen:\n");
                p->volumen = pedir_medida((Unidad[]){M3, CM3}, 2, "Volumen");
                break;
            case 5:
                printf("Nuevo stock: ");
                if (leer_int_seguro(&p->stock)) {
                    printf("‚úÖ Stock actualizado.\n");
                } else printf("‚ùå Entrada inv√°lida.\n");
                break;
            case 0:
                printf("‚Ü© Volviendo al men√∫ anterior.\n");
                break;
            default:
                printf("‚ùå Opci√≥n inv√°lida.\n");
        }
    } while (opcion != 0);
}

// Soft delete (cambia estado a inactivo)
void eliminarProducto(void *dato) {
    Producto *p = (Producto *)dato;
    p->estado = 0;
    printf("üóëÔ∏è Producto marcado como inactivo.\n");
}

void reconstruirReferenciasProducto(Cola *productos, Cola *categorias) {
    if(productos->tam > 0){    
        Nodo *temp = productos->frente;
        while (temp != NULL) {
            Producto *p = (Producto *)temp->dato;
            p->R_categoria = buscarCategoria(categorias, p->id_categoria);
            temp = temp->siguiente;
        }
    }
    else
        puts("No hay productos");
}

void limpiarReferenciasProducto(Cola *productos) {
    Nodo *temp = productos->frente;
    while (temp != NULL) {
        Producto *p = (Producto *)temp->dato;
        p->R_categoria = NULL;
        temp = temp->siguiente;
    }
}

// --------------------------- FUNCIONES DIRECCION ---------------------------
Direccion *crearDireccion(Cola *cola, Localidad *R_localidad, int id_cliente, char calle[], char numero[], char colonia[], char referencias[]) {
    Direccion *nuevo = (Direccion *)malloc(sizeof(Direccion));
    cola->contador_ids++;
    nuevo->id = cola->contador_ids;
    nuevo->R_localidad = R_localidad;
    nuevo->id_localidad = R_localidad->id;
    nuevo->id_cliente = id_cliente;
    nuevo->activo = 1;
    nuevo->historial_pedidos = NULL;

    strcpy(nuevo->calle, calle);
    strcpy(nuevo->numero, numero);
    strcpy(nuevo->colonia, colonia);
    strcpy(nuevo->referencias, referencias);

    return nuevo;
}

Cliente_Direccion* crearCliente_Direccion(Cola *cola, Direccion *direccion, int id_cliente) {
    Cliente_Direccion *nuevo = (Cliente_Direccion *)malloc(sizeof(Cliente_Direccion));
    cola->contador_ids++;
    nuevo->id = direccion->id;
    nuevo->id_cliente = id_cliente;
    nuevo->direccion = direccion;
    return nuevo;
}

int criterioDireccionPorID(void *dato) {
    Direccion *d = (Direccion *)dato;
    int id = 0;
    printf("Ingrese el ID de la direccion: ");
    if (!leer_int_seguro(&id)) {
        printf("‚ùå Entrada inv√°lida.\n");
        return 0;
    }
    return d->id == id;
}

int criterioClienteDireccionPorID(void *dato) {
    Cliente_Direccion *d = (Cliente_Direccion *)dato;
    int id = 0;
    printf("Ingrese el ID de la direcci√≥n: ");
    if (!leer_int_seguro(&id)) {
        printf("‚ùå Entrada inv√°lida.\n");
        return 0;
    }
    return d->id == id && d->direccion->activo;
}

void mostrarDireccion(void *dato) {
    Direccion *d = (Direccion *)dato;
    if (d->activo) {
        printf("\tID Dir: %d | Calle: %s | N√∫mero: %s | Colonia: %s | Ref: %s | Cliente ID: %d | Localidad: %s\n",
               d->id, d->calle, d->numero, d->colonia, d->referencias, d->id_cliente, d->R_localidad->nombre);
    }
}

void mostrarClienteDireccion(void *dato) {
    Cliente_Direccion *d = (Cliente_Direccion *)dato;
    if (d->direccion->activo) {
        printf("\tID Dir: %d | Calle: %s | N√∫mero: %s | Colonia: %s | Ref: %s | Localidad: %s\n",
               d->id, d->direccion->calle,  d->direccion->numero,  d->direccion->colonia,  d->direccion->referencias, d->direccion->R_localidad->nombre);
    }
}

Cliente_Direccion *buscarClienteDireccion(Cola *colaClienteDir, int idDirecc){
    Nodo *temp = colaClienteDir->frente;
    while (temp != NULL) {
        Cliente_Direccion *c = (Cliente_Direccion *)temp->dato;
        if (c->id == idDirecc) 
            return c;
        temp = temp->siguiente;
    }
    return NULL;
}


// Funci√≥n para editar producto con submen√∫ de campos
void editarClienteDireccion(void *dato) {
    Cliente_Direccion *cd = (Cliente_Direccion *)dato;
    Direccion *d = cd->direccion;
    const char *campos[] = {"localidad","calle", "n√∫mero", "colonia", "referencias"};
    int opcion;

    do {
        opcion = menu_edicion("Direcci√≥n", campos, 4);
        if (opcion == -1) continue;
        switch (opcion) {
            case 1:
                printf("Nueva localidad: ");
                listarCola(&colaLoc, mostrarLocalidad);
                int idLoc = 0;
                printf("Ingrese ID de la localidad:");
                if (!leer_int_seguro(&idLoc)) 
                    break;
                Localidad *loc = buscarLocalidad(&colaLoc,idLoc);
                if(loc){
                    d->R_localidad = loc;
                    d->id_localidad = loc->id;
                }
                else{
                    printf("‚ùå Opci√≥n inv√°lida.\n");
                }
                break;
            case 2:
                printf("Nueva calle: ");
                fgets(d->calle, sizeof(d->calle), stdin);
                d->calle[strcspn(d->calle, "\n")] = 0;
                break;
            case 3:
                printf("Nuevo n√∫mero: ");
                fgets(d->numero, sizeof(d->numero), stdin);
                d->numero[strcspn(d->numero, "\n")] = 0;
                break;
            case 4:
                printf("Nueva colonia: ");
                fgets(d->colonia, sizeof(d->colonia), stdin);
                d->colonia[strcspn(d->colonia, "\n")] = 0;
                break;
            case 5:
                printf("Nuevas referencias: ");
                fgets(d->referencias, sizeof(d->referencias), stdin);
                d->referencias[strcspn(d->referencias, "\n")] = 0;
                break;
            case 0:
                printf("‚Ü© Volviendo al men√∫ anterior.\n");
                break;
            default:
                printf("‚ùå Opci√≥n inv√°lida.\n");
        }
    } while (opcion != 0);
}

// Soft delete (cambia estado a inactivo)
void eliminarDireccion(void *dato) {
    Direccion *d = (Direccion *)dato;
    d->activo = 0;
    printf("üóëÔ∏è Direcci√≥n marcada como inactiva.\n");
}

void limpiarReferenciasDireccion(Cola *colaDirecc) {
    Nodo *temp = colaDirecc->frente;
    while (temp != NULL) {
        Direccion *p = (Direccion *)temp->dato;
        p->R_localidad = NULL;
        temp = temp->siguiente;
    }
}

//tarjeta sd para almacenar datos estando en zonas de baja cobertura

// --------------------------- FUNCIONES CLIENTE ---------------------------
Cliente* crearCliente(Cola *cola, char nombre[]) {
    Cliente *nuevo = (Cliente *)malloc(sizeof(Cliente));
    cola->contador_ids++;
    nuevo->id = cola->contador_ids;
    strcpy(nuevo->nombre, nombre);
    inicializarCola(&nuevo->direcciones);
    nuevo->num_pedidos = 0;
    return nuevo;
}

int criterioClientePorID(void *dato) {
    Cliente *c = (Cliente *)dato;
    int id;
    printf("Ingrese el ID del cliente: ");
    if (!leer_int_seguro(&id)) {
        printf("‚ùå Entrada inv√°lida.\n");
        return 0;
    }
    return c->id == id;
}

void mostrarCliente(void *dato) {
    Cliente *c = (Cliente *)dato;
    printf("ID Cliente: %d | Nombre: %s\n", c->id, c->nombre);

    if (c->direcciones.tam > 0){
        listarCola(&c->direcciones,mostrarClienteDireccion);
    }
    return;
    
}
    
void editarCliente(void *dato) {
    Cliente *c = (Cliente *)dato;
    int opcion;
    const char *campos[] = {"nombre", "direccion"};
    do {
        opcion = menu_edicion(c->nombre, campos, 2);
        if (opcion == -1) continue;

        switch (opcion) {
            case 1:
                printf("Nuevo nombre: ");
                fgets(c->nombre, sizeof(c->nombre), stdin);
                c->nombre[strcspn(c->nombre, "\n")] = 0;
                printf("‚úÖ Nombre actualizado.\n");
                break;
            case 2:
                printf("--DIRECCION--");
                listarCola(&c->direcciones,mostrarClienteDireccion);
                editarCola(&c->direcciones,criterioClienteDireccionPorID,editarClienteDireccion);
                break;
            case 0:
                printf("‚Ü© Volviendo al men√∫ anterior.\n");
                break;
            default:
                printf("‚ùå Opci√≥n inv√°lida.\n");
        }
    } while (opcion != 0);
}


Cliente *buscarCliente(Cola *cola, int id_buscar){
    Nodo *temp = cola->frente;
    Cliente *cliente_encontrado = NULL;
    while (temp != NULL) {
        Cliente *c = (Cliente *)temp->dato;
        if (c->id == id_buscar) {
            cliente_encontrado = c;
            break;
        }
        temp = temp->siguiente;
    }
    return cliente_encontrado;
}

void agregarDireccionesACliente(Cliente *cliente, Cola *colaLoc, Cola *colaDirecc) {
    int num = 0;
    printf("¬øCu√°ntas direcciones desea ingresar?: ");
    if (!leer_int_seguro(&num) || num <= 0) {
        printf("‚ùå N√∫mero inv√°lido.\n");
        return;
    }

    if (cliente->direcciones.tam==0) {
        inicializarCola(&cliente->direcciones);
        puts("‚úÖ Cola de direcciones inicializada");
    }

    
    int aux = 0;
    while(aux!=num) {
        char calle[CHAR_M] = {0};
        char numero[CHAR_S] = {0}; 
        char colonia[CHAR_M] = {0}; 
        char referencias[CHAR_G] = {0}; 
        Localidad *loc = NULL;

        listarCola(colaLoc, mostrarLocalidad);
        int idLoc = 0;
        printf("Ingrese ID de la localidad:");
        if (!leer_int_seguro(&idLoc)) 
            continue;
        loc = buscarLocalidad(colaLoc,idLoc);
        if(!loc){
            printf("‚ùå Opci√≥n inv√°lida.\n");
            continue;
        }
        
        
        printf("Calle: ");
        fgets(calle, sizeof(calle), stdin);
        calle[strcspn(calle, "\n")] = 0;
        if (!es_texto_valido(calle, "Calle"))
            continue;

        printf("N√∫mero (I:1340|E:B-20|): ");
        fgets(numero, sizeof(numero), stdin);
        numero[strcspn(numero, "\n")] = 0;
        if (!es_texto_valido(numero, "Numero"))
            continue;

        printf("Colonia: ");
        fgets(colonia, sizeof(colonia), stdin);
        colonia[strcspn(colonia, "\n")] = 0;
        if (!es_texto_valido(colonia, "Colonia"))
            continue;

        printf("Referencias (opcional): ");
        fgets(referencias, sizeof(referencias), stdin);
        referencias[strcspn(referencias, "\n")] = 0;

        Nodo* dir = encolar(colaDirecc, crearDireccion(colaDirecc,loc,cliente->id,calle,numero,colonia,referencias),sizeof(Direccion));
        if(!dir){
            printf("‚ùå ¬°Error! No se pudo insertar la direccion.\n");
        }
        else{
            Direccion *d = (Direccion *)dir->dato;
            if(encolar(&cliente->direcciones,crearCliente_Direccion(&cliente->direcciones,d,cliente->id),sizeof(Cliente_Direccion))){
                printf("‚úÖ Se agreg√≥: ");
                mostrarDireccion(d);
                puts("");
            }
            else
                printf("‚ùå ¬°Error! No se pudo insertar la direccion.\n");
        }
        aux ++;
    }

    printf("‚úÖ Direcciones agregadas.\n");
}

void limpiarReferenciasClienteDireccion(Cola *colaCliente, Cola *colaDirecc) {
    Nodo *nodoCliente = colaCliente->frente;

    while (nodoCliente != NULL) {
        Cliente *cliente = (Cliente *)nodoCliente->dato;

        // Liberar cada Cliente_Direccion
        Nodo *nodoDir = cliente->direcciones.frente;
        while (nodoDir != NULL) {
            Nodo *temp = nodoDir;
            nodoDir = nodoDir->siguiente;

            if (temp->dato != NULL) {
                Cliente_Direccion *cd = (Cliente_Direccion *)temp->dato;
                cd->direccion = NULL;
                free(cd);
            }
            free(temp);
        }

        // Resetear la cola interna
        cliente->direcciones.frente = NULL;
        cliente->direcciones.final = NULL;
        cliente->direcciones.tam = 0;
        cliente->direcciones.contador_ids = 0;

        nodoCliente = nodoCliente->siguiente;
    }

    // Limpiar referencias de R_localidad en cada direcci√≥n
    Nodo *nodoGlobalDir = colaDirecc->frente;
    while (nodoGlobalDir != NULL) {
        Direccion *d = (Direccion *)nodoGlobalDir->dato;
        if (d) {
            d->R_localidad = NULL;
        }
        nodoGlobalDir = nodoGlobalDir->siguiente;
    }
}




// --------------------------- FUNCIONES COLAS ---------------------------
void inicializarCola(Cola *cola) {
    cola->frente = NULL;
    cola->final = NULL;
    cola->tam = 0;
    cola->contador_ids = 0;
}

Nodo *encolar(Cola *cola, void *dato, size_t tam_dato) {
    if (!dato){
        return NULL;
    }
    Nodo *nuevo = (Nodo *)malloc(sizeof(Nodo));
    nuevo->dato = malloc(tam_dato);
    memcpy(nuevo->dato, dato, tam_dato);
    nuevo->siguiente = NULL;

    if (cola->final == NULL)
        cola->frente = cola->final = nuevo;
    else {
        cola->final->siguiente = nuevo;
        cola->final = nuevo;
    }

    cola->tam++;
    return nuevo;  // ‚úÖ retornamos el puntero al nodo insertado
}

void *desencolar(Cola *cola) {
    if (cola->frente == NULL) {
        printf("‚ö† La cola est√° vac√≠a.\n");
        return NULL;
    }

    Nodo *temp = cola->frente;
    void *dato = temp->dato;

    cola->frente = cola->frente->siguiente;
    if (cola->frente == NULL)
        cola->final = NULL;

    free(temp);
    cola->tam--;

    return dato;  // El dato debe ser procesado antes de ser liberado externamente
}

void listarCola(Cola *cola, void (*mostrar)(void *)) {
    Nodo *temp = cola->frente;
    if (temp == NULL) {
        printf("üìã La cola est√° vac√≠a.\n");
        return;
    }

    printf("üìã Listado de elementos:\n");
    while (temp != NULL) {
        mostrar(temp->dato);
        temp = temp->siguiente;
    }
}

void editarCola(Cola *cola, int (*criterio)(void *), void (*editar)(void *)) {
    Nodo *temp = cola->frente;
    while (temp != NULL) {
        if (criterio(temp->dato)) {
            editar(temp->dato);
            printf("‚úÖ Elemento editado.\n");
            return;
        }
        temp = temp->siguiente;
    }
    printf("‚ùå Elemento no encontrado.\n");
}

void cargarCola(Cola *cola, const char *nombre_archivo, size_t tam_dato) {
    inicializarCola(cola);

    FILE *archivo = fopen(nombre_archivo, "rb");
    if (!archivo) {
        printf("‚ö† No se encontr√≥ archivo '%s'.\n", nombre_archivo);
        return;
    }

    ColaHeader header;
    fread(&header, sizeof(ColaHeader), 1, archivo);  // ‚úÖ lee encabezado
    cola->contador_ids = header.contador_ids;
    cola->tam = header.tam;

    void *buffer = malloc(tam_dato);
    for (int i = 0; i < cola->tam; i++) {
        if (fread(buffer, tam_dato, 1, archivo) == 1) {
            encolar(cola, buffer, tam_dato);
        }
    }

    free(buffer);
    fclose(archivo);
    printf("üìÇ Cola cargada desde '%s'.\n", nombre_archivo);
}


void guardarCola(Cola *cola, const char *nombre_archivo, size_t tam_dato) {
    FILE *archivo = fopen(nombre_archivo, "wb");
    if (!archivo) {
        printf("‚ùå Error al abrir archivo '%s'.\n", nombre_archivo);
        return;
    }

    ColaHeader header = {cola->contador_ids, cola->tam};
    fwrite(&header, sizeof(ColaHeader), 1, archivo);  // ‚úÖ guarda encabezado

    Nodo *temp = cola->frente;
    while (temp != NULL) {
        fwrite(temp->dato, tam_dato, 1, archivo);
        temp = temp->siguiente;
    }

    fclose(archivo);
    printf("üíæ Cola guardada en '%s'.\n", nombre_archivo);
}


void liberarCola(Cola *cola) {
    Nodo *actual = cola->frente;
    while (actual != NULL) {
        Nodo *temp = actual;
        actual = actual->siguiente;
        free(temp->dato);
        free(temp);
    }
    cola->frente = NULL;
    cola->final = NULL;
    cola->tam = 0;
}

Nodo *extraerNodoPorCriterio(Cola *cola, int (*criterio)(void *)) {
    Nodo *actual = cola->frente;
    Nodo *anterior = NULL;

    while (actual != NULL) {
        if (criterio(actual->dato)) {
            // Reorganizar punteros
            if (anterior == NULL) {
                // Es el primer nodo
                cola->frente = actual->siguiente;
                if (cola->frente == NULL)
                    cola->final = NULL;
            } else {
                anterior->siguiente = actual->siguiente;
                if (actual == cola->final)
                    cola->final = anterior;
            }

            cola->tam--;
            return actual;  // ‚úÖ retornar el nodo extra√≠do
        }

        anterior = actual;
        actual = actual->siguiente;
    }

    return NULL;  // ‚ùå No encontrado
}


// --------------------------- MENUS SECUNDARIOS ---------------------------

int menu_edicion(const char *titulo, const char *campos[], int num_campos) {
    int opcion = -1;
    printf("\n-- Editando %s --\n", titulo);
    for (int i = 0; i < num_campos; i++) {
        printf("%d. Editar %s\n", i + 1, campos[i]);
    }
    printf("0. Volver\n");
    printf("Seleccione una opci√≥n: ");

    if (!leer_int_seguro(&opcion)) {
        printf("‚ùå Entrada inv√°lida.\n");
        return -1;
    }

    if (opcion < 0 || opcion > num_campos) {
        printf("‚ùå Opci√≥n inv√°lida.\n");
        return -1;
    }

    return opcion;
}

const char* obtener_nombre_unidad(Unidad u) {
    switch (u) {
        case KG: return "KG";
        case G: return "G";
        case M3: return "M3";
        case CM3: return "CM3";
        case KM: return "KM";
        case H: return "Horas";
        case MIN: return "Minutos";
        default: return "Desconocido";
    }
}


// --------------------------- SUBMENUS ---------------------------
void submenu_categoria(Cola *colaCat) {
    int op = 0;
    do {
        printf("\n-- SUBMEN√ö CATEGOR√çA --\n");
        printf("1. Insertar\n2. Editar\n3. Listar\n0. Volver\nSeleccione una opci√≥n: ");
        if (!leer_int_seguro(&op)) continue;

        switch (op) {
            case 1: {
                char nombre[CHAR_S] = {0};
                printf("Nombre categor√≠a: ");
                fgets(nombre, sizeof(nombre), stdin);
                nombre[strcspn(nombre, "\n")] = 0;
                if (es_texto_valido(nombre, "Nombre Categor√≠a"))
                    if(!encolar(colaCat, crearCategoria(colaCat,nombre),sizeof(Categoria)))
                         printf("‚ùå ¬°Error! No se pudo insertar la direccion.\n");
            } break;
            case 2: editarCola(colaCat,criterioCategoriaPorID,editarCategoriaNombre); break;
            case 3: listarCola(colaCat,mostrarCategoria); break;
            case 0: printf("‚Ü© Volviendo al men√∫ anterior.\n"); break;
            default: printf("‚ùå Opci√≥n inv√°lida.\n");
        }
    } while (op != 0);
}

void submenu_localidad(Cola*colaLoc) {
    int op = 0;
    do {
        printf("\n-- SUBMEN√ö LOCALIDAD --\n");
        printf("1. Insertar\n2. Editar\n3. Listar\n0. Volver\nSeleccione una opci√≥n: ");
        if (!leer_int_seguro(&op)) continue;

        switch (op) {
            case 1: {
                char nombre[CHAR_S];
                printf("Nombre localidad: ");
                fgets(nombre, sizeof(nombre), stdin);
                nombre[strcspn(nombre, "\n")] = 0;
                if (es_texto_valido(nombre, "Nombre Localidad")) {
                    Coordenadas coor = pedir_coordenadas();
                    if (!encolar(colaLoc, crearLocalidad(colaLoc,nombre,coor),sizeof(Localidad)))
                        printf("‚ùå ¬°Error! No se pudo insertar.\n");
                }
            } break;
            case 2: editarCola(colaLoc,criterioLocalidadPorID,editarLocalidad); break;
            case 3: listarCola(colaLoc,mostrarLocalidad); break;
            case 0: printf("‚Ü© Volviendo al men√∫ anterior.\n"); break;
            default: printf("‚ùå Opci√≥n inv√°lida.\n");
        }
    } while (op != 0);
}

void submenu_producto(Cola *colaProd, Cola *colaCat) {
    int op = 0;
    do {
        printf("\n-- SUBMEN√ö PRODUCTO --\n");
        printf("1. Insertar\n2. Editar\n3. Eliminar (marcar inactivo)\n4. Listar\n0. Volver\nSeleccione una opci√≥n: ");
        if (!leer_int_seguro(&op)) continue;

        switch (op) {
            case 1: {
                char nombre[CHAR_S] = {0};
                printf("Nombre producto: ");
                fgets(nombre, sizeof(nombre), stdin);
                nombre[strcspn(nombre, "\n")] = 0;
                if (!es_texto_valido(nombre, "Nombre Producto")) break;

                printf("Ingrese valor econ√≥mico: ");
                float valor = 0;
                if (!leer_float_seguro(&valor)) {
                    printf("‚ùå Entrada inv√°lida.\n");
                    break;
                }

                puts("--Peso--");
                Medida peso = pedir_medida((Unidad[]){KG, G}, 2, "Peso");

                puts("--Volumen--");
                Medida volumen = pedir_medida((Unidad[]){M3, CM3}, 2, "Volumen");

                printf("Ingrese stock inicial: ");
                int stock = 0;
                if (!leer_int_seguro(&stock)) {
                    printf("‚ùå Entrada inv√°lida.\n");
                    break;
                }
                puts("----------");
                    listarCola(colaCat, mostrarCategoria);
                printf("Seleccione una categor√≠a existente: ");

                int idCat = 0;
                if (!leer_int_seguro(&idCat)) {
                    printf("‚ùå Entrada inv√°lida.\n");
                    break;
                }
                Categoria *categoria_seleccionada = buscarCategoria(colaCat,idCat);

                if (!categoria_seleccionada) {
                    printf("‚ùå Categor√≠a no encontrada.\n");
                    break;
                }
                if(!encolar(colaProd, crearProducto(colaProd, nombre, categoria_seleccionada, valor, peso, volumen, stock), sizeof(Producto)))
                    printf("‚ùå ¬°Error! No se pudo insertar la direccion.\n");
            } break;
            case 2: editarCola(colaProd, criterioProductoPorID, editarProducto); break;
            case 3: editarCola(colaProd, criterioProductoPorID, eliminarProducto); break;
            case 4: listarCola(colaProd, mostrarProducto); break;
            case 0: printf("‚Ü© Volviendo al men√∫ anterior.\n"); break;
            default: printf("‚ùå Opci√≥n inv√°lida.\n");
        }
    } while (op != 0);
}


void submenu_cliente(Cola *colaCliente, Cola *colaLoc, Cola *colaDirecc) {
    int op;
    do {
        printf("\n-- SUBMEN√ö CLIENTE --\n");
        printf("1. Insertar cliente\n2. Agregar direcciones a cliente\n3. Editar cliente\n");
        printf("4. Eliminar direcci√≥n (desactivar) o cliente\n5. Listar clientes con direcciones\n6. Listar Direcciones\n0. Volver\nSeleccione una opci√≥n: ");
        if (!leer_int_seguro(&op)) continue;

        switch (op) {
            case 1: {
                char nombre[CHAR_S];
                printf("Nombre cliente: ");
                fgets(nombre, sizeof(nombre), stdin);
                nombre[strcspn(nombre, "\n")] = 0;
                if (es_texto_valido(nombre, "Nombre Cliente"))
                    if(!encolar(colaCliente, crearCliente(colaCliente, nombre), sizeof(Cliente)))
                         printf("‚ùå ¬°Error! No se pudo insertar la direccion.\n");
            } break;

            case 2: {
                listarCola(colaCliente, mostrarCliente);
                int idCli = 0;
                printf("Ingrese ID del cliente para agregar direcciones: ");
                if (!leer_int_seguro(&idCli)) break;

                Cliente *cliente_encontrado = buscarCliente(colaCliente,idCli);

                if (!cliente_encontrado) {
                    printf("‚ùå Cliente no encontrado.\n");
                    break;
                }
                agregarDireccionesACliente(cliente_encontrado, colaLoc, colaDirecc);
            } break;

            case 3: {
                listarCola(colaCliente,mostrarCliente);
                editarCola(colaCliente,criterioClientePorID,editarCliente);
            } break;

        case 4: {
            listarCola(colaCliente, mostrarCliente);
            int idCli = 0;
            printf("Ingrese ID del cliente: ");
            if (!leer_int_seguro(&idCli)) 
                break;

            Cliente *cliente_encontrado = buscarCliente(colaCliente,idCli);

            if(!cliente_encontrado){
                printf("‚ùå Cliente no encontrado.\n");
                break;
            }

            // 1. Mostrar las direcciones del cliente
            printf("üìã Direcciones del cliente:\n");
            listarCola(&cliente_encontrado->direcciones,mostrarClienteDireccion);
            int idDir = 0;
            printf("Ingrese ID de la direccion: ");
            if (!leer_int_seguro(&idDir)) 
                break;

            Nodo* nodoExtraido = extraerNodoPorCriterio(&cliente_encontrado->direcciones,criterioClienteDireccionPorID);

            Nodo *nodoDireccionGlobal = *(Nodo **)nodoExtraido->dato;
            Direccion *d = (Direccion *)nodoDireccionGlobal->dato;

            // 3. Desactivar la direcci√≥n global
            d->activo = 0;

            // 4. Liberar el nodo de la cola interna
            free(nodoExtraido->dato);  // liberar el puntero a Nodo *
            free(nodoExtraido);
            cliente_encontrado->direcciones.tam--;
            
            cliente_encontrado->direcciones.tam--;
            printf("‚úÖ Direcci√≥n desactivada y referencia eliminada del cliente.\n");
        } break;
            case 5: listarCola(colaCliente, mostrarCliente); break;
            
            case 6: listarCola(colaDirecc, mostrarDireccion); break;

            case 0: printf("‚Ü© Volviendo al men√∫ anterior.\n"); break;

            default: printf("‚ùå Opci√≥n inv√°lida.\n");
        }
    } while (op != 0);
}


// --------------------------- MENU PRINCIPAL ---------------------------

void menu_admin(Cola *colaCat, Cola *colaLoc, Cola *colaProd, Cola *colaCliente, Cola *colaDirecc) {
    int op;
    do {
        printf("\n=== MEN√ö ADMINISTRADOR ===\n");
        printf("1. Categor√≠a\n2. Localidad\n3. Producto\n4. Clientes y Direcciones\n0. Salir\nSeleccione una opci√≥n: ");
        if (!leer_int_seguro(&op)) 
            continue;

        switch (op) {
            case 1: submenu_categoria(colaCat); break;
            case 2: submenu_localidad(colaLoc); break;
            case 3: submenu_producto(colaProd,colaCat); break;
            case 4: submenu_cliente(colaCliente,colaLoc,colaDirecc); break;
            case 0: printf("üëã Saliendo modo Admin\n"); break;
            default: printf("‚ùå Opci√≥n inv√°lida.\n");
        }
    } while (op != 0);
}

void asociarDireccionesPorCliente(Cola *colaCliente, Cola *colaDirecc) {
    if (colaCliente->tam == 0 || colaDirecc->tam == 0) return;

    // Paso 1: Crear arreglo de punteros a Cliente indexado por ID
    int max_id = colaCliente->contador_ids;
    Cliente **clientesPorID = (Cliente **)calloc(max_id + 1, sizeof(Cliente *));
    if (!clientesPorID) {
        printf("‚ùå Error al asignar memoria para arreglo de clientes.\n");
        return;
    }

    Nodo *nodoCli = colaCliente->frente;
    while (nodoCli != NULL) {
        Cliente *c = (Cliente *)nodoCli->dato;
        if (c->id <= max_id) {
            clientesPorID[c->id] = c;
        }
        nodoCli = nodoCli->siguiente;
    }

    // Paso 2: Recorrer las direcciones y asignar a su cliente correspondiente
    Nodo *nodoDir = colaDirecc->frente;
    while (nodoDir != NULL) {
        Direccion *d = (Direccion *)nodoDir->dato;
        if (!d->activo) {
            nodoDir = nodoDir->siguiente;
            continue;
        }

        if (d->id_cliente > 0 && d->id_cliente <= max_id) {
            Cliente *cliente = clientesPorID[d->id_cliente];
            if (cliente) {
                if (cliente->direcciones.frente == NULL)
                    inicializarCola(&cliente->direcciones);

                Cliente_Direccion *cd = (Cliente_Direccion *)malloc(sizeof(Cliente_Direccion));
                cd->id = d->id;
                cd->id_cliente = cliente->id;
                cd->direccion = d;

                encolar(&cliente->direcciones, cd, sizeof(Cliente_Direccion));
            }
        }

        nodoDir = nodoDir->siguiente;
    }

    free(clientesPorID);  // Liberamos el arreglo auxiliar
}

void asociarLocalidadesADirecciones(Cola *colaDirecc, Cola *colaLoc) {
    Nodo *nodoDir = colaDirecc->frente;

    while (nodoDir != NULL) {
        Direccion *d = (Direccion *)nodoDir->dato;
        if (d && d->activo) {
            Localidad *loc = buscarLocalidad(colaLoc, d->id_localidad);
            if (loc) {
                d->R_localidad = loc;
            } else {
                d->R_localidad = NULL;
                printf("‚ö†Ô∏è Localidad con ID %d no encontrada para direcci√≥n ID %d.\n", d->id_localidad, d->id);
            }
        }
        nodoDir = nodoDir->siguiente;
    }
}

int main() {
    //SetConsoleOutputCP(65001); // Cambiar c√≥digo de p√°gina a UTF-8

    Cola colaCat;
    //Cola colaLoc;
    Cola colaProd;
    Cola colaCliente;
    Cola colaDirecc;

    inicializarCola(&colaCat);
    inicializarCola(&colaLoc);
    inicializarCola(&colaProd);
    inicializarCola(&colaCliente);
    inicializarCola(&colaDirecc);

    // Cargar datos al inicio
    cargarCola(&colaCat, "categorias.bin",sizeof(Categoria));
    cargarCola(&colaLoc, "localidades.bin",sizeof(Localidad));
    cargarCola(&colaProd, "productos.bin",sizeof(Producto));
    cargarCola(&colaCliente, "clientes.bin",sizeof(Cliente));
    cargarCola(&colaDirecc, "direcciones.bin",sizeof(Direccion));
    

    reconstruirReferenciasProducto(&colaProd,&colaCat);
    asociarDireccionesPorCliente(&colaCliente, &colaDirecc);
    asociarLocalidadesADirecciones(&colaDirecc, &colaLoc);

    menu_admin(&colaCat, &colaLoc, &colaProd, &colaCliente, &colaDirecc);

    
    limpiarReferenciasProducto(&colaProd);
    limpiarReferenciasClienteDireccion(&colaCliente,&colaDirecc);


    // Guardar datos al salir
    guardarCola(&colaCat, "categorias.bin",sizeof(Categoria));
    guardarCola(&colaLoc, "localidades.bin",sizeof(Localidad));
    guardarCola(&colaProd, "productos.bin",sizeof(Producto));
    guardarCola(&colaCliente, "clientes.bin",sizeof(Cliente));
    guardarCola(&colaDirecc, "direcciones.bin",sizeof(Direccion));


    liberarCola(&colaCat);
    liberarCola(&colaLoc);
    liberarCola(&colaProd);
    liberarCola(&colaCliente);
    liberarCola(&colaDirecc);

    return 0;
}